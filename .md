Descripción general del sistema
App web para partidas de ajedrez Humano vs IA (LLMs) o IA vs IA, con análisis post-partida y modo torneo.

Tiempo real:  tablero con drag & drop, validación legal en el servidor con chess.js, timers y registro

Se desarrollará con React + TS (UI), Node.js + TS (API + Socket.IO), PostgreSQL (DB), Redis + BullMQ (jobs).

IA: proveedores LLM (Claude/Gemini/DeepSeek), fallback Stockfish.
# Chess backend

# ¿que llevará?
Partidas en tiempo real con tablero interactivo y validación legal server-side (chess.js).
Configuración de partida: humano/IA, proveedor de IA y nivel.
Registro de movimientos y exportación PGN.
Análisis post-partida con IA (errores, alternativas).
Modo torneo IA vs IA y tabla de posiciones.
Estadísticas: partidas jugadas, ratios de victoria, promedios.

# interfaces de comunicación 
     Frontend ⇄ Backend (REST – HTTP/JSON)
Propósito: Operaciones síncronas y consultivas: crear partida, listar proveedores/“niveles” de IA, consultar historial/estadísticas, exportar PGN.
Qué viaja: Configuración de partida (blancas/negras: humano o IA, proveedor, nivel), identificadores, estado inicial y metadatos.

    Frontend ⇄ Backend (WebSocket – Socket.IO)
Propósito: Tiempo real: unirse a la sala de la partida, enviar jugadas, recibir el estado del tablero, relojes, log de movimientos, notificaciones de “IA pensando”, fin de partida y análisis listo.
Qué viaja: Eventos: join, move, state, move_made, game_over, analysis_ready.
Servidor autoritativo: toda jugada se valida con chess.js.
Orden por partida (sin “doble movimiento”): locking por juego.


    Backend ⇄ Redis (pubsub) + BullMQ (colas)
Propósito: Procesamiento asíncrono, encolar ai-move (jugadas IA), analysis (post-partida) y tareas de torneo; difundir eventos entre instancias del backend.
Qué viaja: Cargas compactas por partida (gameId, FEN/PGN, proveedor, nivel).

    Workers ⇄ Proveedores LLM (APIs HTTP)
Propósito: Solicitar una jugada o análisis post-partida.
Qué viaja: Contexto mínimo de tablero (FEN/PGN) y “nivel” configurado; .
Salida estructurada (movimiento único, breve razonamiento, confianza) y verificación con chess.js.
Tiempos acotados y reintentos limitados; control de frecuencia/costo por proveedor.
Errores/Degradación: Si la IA falla o devuelve una jugada inválida varias veces, fallback con Stockfish y notificación a la sala.

    Workers ⇄ Motor Stockfish
Propósito: Respaldo determinista y/o evaluación objetiva.
Qué viaja: Posición (FEN) y parámetros de búsqueda (profundidad o milisegundos); respuesta bestmove.
Cuándo se usa: Fallback cuando el LLM falla o para análisis comparativo (IA vs motor clásico).
Garantías: Jugada legal y tiempos previsibles.

    Backend ⇄ Base de datos (PostgreSQL)
Propósito: Persistencia canónica de partidas, movimientos (con FEN/PGN), resultados, análisis y torneos.
Qué viaja: Inserciones por jugada y actualización de estado/PGN; consultas de historial y estadísticas.

